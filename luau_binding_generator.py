# Mirrors a lot of what the godot-cpp binder does.
# Some code is similar or the same.

import importlib.machinery
import importlib.util

import json
from pathlib import Path


def load_cpp_binding_generator():
    # lol

    godot_cpp_path = Path(__file__).parent / \
        "../godot-cpp/binding_generator.py"
    loader = importlib.machinery.SourceFileLoader(
        "binding_generator", str(godot_cpp_path))
    spec = importlib.util.spec_from_loader("binding_generator", loader)
    binding_generator = importlib.util.module_from_spec(spec)
    loader.exec_module(binding_generator)

    return binding_generator


binding_generator = load_cpp_binding_generator()

header_comment = "// This file is automatically generated. Do not edit!"
indent = "    "


def scons_emit_files(target, source, env):
    files = [
        env.File("gen/src/luagd_builtins.gen.cpp"),
        env.File("gen/include/luagd_builtins_stack.gen.h")
    ]

    env.Clean(files, target)

    return target + files, source


def scons_generate_bindings(target, source, env):
    generate_luau_bindings(
        str(source[0]),
        target[0].abspath
    )

    return None


def should_skip_class(class_name):
    to_skip = [
        "Nil",
        "bool",
        "int",
        "float",
        "String"
    ]

    return class_name in to_skip


def append(source, indent_level, line):
    lines = [indent * indent_level +
             l if len(l) > 0 else "" for l in line.split("\n")]
    source.append("\n".join(lines))


def generate_luau_builtins(src_dir, include_dir, builtin_classes):
    src_path = src_dir / "luagd_builtins.gen.cpp"
    header_path = include_dir / "luagd_builtins_stack.gen.h"

    src = [header_comment, ""]
    header = [header_comment, ""]

    src.append("""\
#include "luagd_builtins.h"

#include "luagd.h"
#include "luagd_stack.h"
#include "luagd_builtins_stack.gen.h"

#include <lua.h>
#include <lualib.h>
#include <godot_cpp/variant/builtin_types.hpp>

void luaGD_openbuiltins(lua_State *L)
{
    LUAGD_LOAD_GUARD(L, "_gdBuiltinsLoaded");
    const char *meta_type_key = "__fortype";
"""
               )

    header.append("""\
#pragma once

#include "luagd_stack.h"

#include <godot_cpp/variant/builtin_types.hpp>

using namespace godot;
"""
                  )

    stack_ops = []

    indent_level = 1

    for b_class in builtin_classes:
        class_name = b_class["name"]

        if should_skip_class(class_name):
            continue

        append(src, indent_level, "{ // " + class_name)
        indent_level += 1

        metatable_name = "Godot.Builtin." + class_name
        append(src, indent_level,
               f"const char *metatable_name = \"{metatable_name}\";")

        # Create metatable
        append(src, indent_level, "luaL_newmetatable(L, metatable_name);")

        # TODO

        # Pop metatable
        append(src, indent_level, "lua_pop(L, 1);")

        src.append("")

        # Create global table
        append(src, indent_level, """\
lua_newtable(L); // global table
lua_createtable(L, 0, 3); // metatable
lua_pushstring(L, metatable_name);
lua_setfield(L, -2, meta_type_key);
"""
               )

        # TODO: __call (constructor)
        # TODO: methods on global table

        append(src, indent_level, f"""
lua_setreadonly(L, -1, true);
lua_setmetatable(L, -2);
lua_setglobal(L, \"{class_name}\");\
""")

        indent_level -= 1
        append(src, indent_level, "} // " + class_name)

        # Stack operation
        if "has_destructor" in b_class and b_class["has_destructor"]:
            stack_ops.append(
                f"LUA_UDATA_STACK_OP({class_name}, {metatable_name}, DTOR({class_name}));")
        else:
            stack_ops.append(
                f"LUA_UDATA_STACK_OP({class_name}, {metatable_name}, NO_DTOR);")

        header.append(f"template class LuaStackOp<{class_name}>;")

        if b_class != builtin_classes[-1]:
            src.append("")

    src.append("}")
    src.append("")

    src.append("\n".join(stack_ops))

    # Save
    with src_path.open("w+") as output_file:
        output_file.write("\n".join(src))

    with header_path.open("w+") as output_file:
        output_file.write("\n".join(header))


def generate_luau_bindings(api_filepath, output_dir):
    api = None

    with open(api_filepath) as api_file:
        api = json.load(api_file)

    src_dir = Path(output_dir) / "gen" / "src"
    src_dir.mkdir(parents=True, exist_ok=True)

    include_dir = Path(output_dir) / "gen" / "include"
    include_dir.mkdir(parents=True, exist_ok=True)

    generate_luau_builtins(src_dir, include_dir, api["builtin_classes"])
